<!DOCTYPE html>
<html>
  <head>
    <title>RUBY IN TAB</title>

    <meta charset='utf-8' />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

    <link type="text/css" rel="stylesheet" media="screen" href="css/sidetap.css" />
    <link type="text/css" rel="stylesheet" media="screen" href="css/default.css" />
    <link type="text/css" rel="stylesheet" media="screen" href="css/styles.css" />
    <link type="text/css" rel="stylesheet" media="screen" href="css/rainbow.css" />
  </head>
  <body>
    <div class="sidetap">
      <div class="stp-nav">
        <div>
          <nav>
            <a href="#" class="selected">Home</a>
            <a href="#" id="link_to_ruby_home">RubyQuickTips</a>
            <a href="#" id="link_to_history">History</a>
            <a href="#" id="link_to_fav">Fav</a>
            <a href="#" id="link_to_about">About</a>
          </nav>
        </div>
      </div>

      <div class="stp-content" id="content">
        <header class="stp-fake-header">&nbsp;</header>
        <div class="stp-overlay nav-toggle">&nbsp;</div>

        <!-- Content Divs Look Like This -->
        <div class="stp-content-panel" id="home">
          <header>
            <a href="javascript:void(0)" class="header-button icon menu"><span>Menu</span></a>
            <a href="javascript:void(0)" class="header-button right" id="action_clear"><span>Clear</span></a>
            <h1>Ruby In Tab</h1>
          </header>
          <div class="stp-content-frame">
            <div class="stp-content-body">
              <div class="container">
                <textarea placeholder="Your ruby code here" id="editor"></textarea>
                <input type="button" class="run_me big_btn" value ="RUN">
                <div id="output"></div>
              </div>
            </div>
          </div>
        </div>
        <!-- End content Div -->


        <!-- Content Divs Look Like This -->
        <div class="stp-content-panel hidden" id="about">
         <header>
            <a href="javascript:void(0)" class="header-button cancel right">Back</a>
            <h1>What's This?</h1>
          </header>
          <div class="stp-content-frame">
            <div class="stp-content-body">
              <div class="container about_rubyintab">
                RubyInTab is an app that enables you to play with ruby in your android device.<br />
                Ruby quick tip section contains tips, tricks and snippets that you may or may not be familiar with.<br />
                The app was developed as a personal project that would help me to try out ruby in my android devise and collect ruby tricks and snippets that may be tried and learned on the go.
                <br /><br />
                Thank You for using this app.
                <br />
                Would love to hear comments and feedback.
                <br /><br />
                <a href="http:twitter.com/roxxypoxxy" class="button_class">@roxxypoxxy</a>
                <br /><br />
                Share the joy: <br />
                <a href="#" class="button_class">Share with FB friends</a>
                <a href="#" class="button_class">Tweet about RubyIntab</a>
              </div>
            </div>
          </div>
        </div>
        <!-- End content Div -->

         <!-- Content Divs Look Like This -->
        <div class="stp-content-panel hidden" id="history">
         <header>
            <a href="javascript:void(0)" class="header-button cancel right">Back</a>
            <h1>History</h1>
          </header>
          <div class="stp-content-frame">
            <div class="stp-content-body">
              <div class="container">
                History of snippets ..
                <br/>
                Comming Soon ..
              </div>
            </div>
          </div>
        </div>
        <!-- End content Div -->

         <!-- Content Divs Look Like This -->
        <div class="stp-content-panel hidden" id="fav">
         <header>
            <a href="javascript:void(0)" class="header-button cancel right">Back</a>
            <h1>Favourites</h1>
          </header>
          <div class="stp-content-frame">
            <div class="stp-content-body">
              <div class="container">
                Favourite snippets ..
                <br />
                Comming Soon ..
              </div>
            </div>
          </div>
        </div>
        <!-- End content Div -->

        <!-- Content Divs Look Like This -->
        <div class="stp-content-panel hidden" id="ruby_home">
         <header>
            <a href="javascript:void(0)" class="header-button cancel right">Back</a>
             <h1>RubyQuickTips</h1>
          </header>
          <div class="stp-content-frame">
            <div class="stp-content-body">
              <div class="container ruby_home">
                <p>
                  This guide is not a beginner guide as we directly discuss OOP with ruby, and move into advance features and tricks using ruby classes, modules, procs and blocks. This guide assumes that reader has basic knowledge of basics of  ruby like ruby basic variables, constants, data types, operators, control structures, methods and operators.
                  <br />
                  For beginners, I highly recommend <a href="">Ruby</a> app which is freely available at google playstore.
                </p>
                <h1>Ruby :: Diving into Classes</h1>
                <p>Lets start with Ruby classes. Defining a class lets you group behaviors (methods) into convenient bundles, so that you can quickly create many objects that behave essentially the same way. Let's define a full blown ruby class:</p>
                <br />
                <pre>
                  <code data-language="ruby">
                class Person
                  # initialize method is called when every new object is created
                  def initialize(first, last)
                    @first = first
                    @last  = last
                  end
                  def full_name
                    [@first,@last].compact.join(',')
                  end
                end
                person1 = Person.new('Ian','Wimbley')
                puts person1.full_name
                  </code>
                </pre>
                <p>
                  In the above example we have defined a ruby class Person with instance variables @first and @last and instance method full_name and we created an object of Person using Person.new.<br />
                  Information and data associated with a particular object embodies the state of the object. Ruby objects come with their own storage and retrieval mechanism for values: instance variables and are represented by @ before the variable name.The instance variable enables individual objects to remember state.
                  Instance variables work much like other variables: you assign values to them, and you read those values back; you can add them together, print them out, and so on. But instance variables have a few differences:
                 <ul>
                  <li>Instance variable names always start with @ (the at sign). This enables you to rec- ognize an instance variable at a glance.</li>
                  <li>Instance variables are only visible to the object to which they belong.</li>
                 </ul>
              </p>
              <h2>Getter and Setters</h2>
              <p>
                Ruby provides a built-in short-cuts that automatically creates a method that reads and returns the value of the instance variable with the same name as the method (give or take an @). It works like this:</p><br />
                <pre>
                    <code data-language="ruby">
                  class Person
                    attr_reader :name, :age, :gender
                  end
                  </code>
                </pre>
                <p>The elements that start with colons (:name, and so on) are symbols. Symbols are a kind of naming or labeling facility. They’re a cousin of strings, although not quite the same thing.
              </p><br />
              <pre>
                  <code data-language="ruby">
                class Person

                  attr_reader :status
                  attr_writer :person_id
                  attr_accessor :contact

                  # initialize method is called when every new object is created
                  def initialize(first, last)
                    @first = first
                    @last  = last
                    @status = ''
                  end
                  def full_name
                    [@first,@last].compact.join(',')
                  end
                end
                person1 = Person.new('Ian','Wimbley')
                puts person1.full_name
                person1.contact = 9849942644
                person1.person_id = 1
                puts person1.contact
                puts person1.status
                puts person1.id # gives error
                  </code>
                </pre>
                <p>Summary of attr_* methods:</p>
                  <br />
                  <table>
                    <thead>
                      <tr><th>Method name</th><th>Effect</th><th>Example</th><th>Equivalent code</th></tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>attr_reader</td>
                        <td>Creates a reader method</td>
                        <td>attr_reader :venue</td>
                        <td>
                          <pre>
                            def venue @venue
                            end
                          </pre>
                        </td>
                      </tr>
                    <tr>
                      <td>attr_writer</td>
                      <td>Creates a writer method</td>
                      <td>attr_writer :price</td>
                      <td>
                        <pre>
                          def price=(price)
                            @price = price
                          end
                        </pre>
                      </td>
                    </tr>
                    <tr>
                      <td>attr_accessor</td>
                      <td>Creates reader and writer meth- ods</td>
                      <td>attr_accessor :price</td>
                      <td>
                        <pre>
                          def price=(price)
                            @price = price
                          end
                          def price
                            @price
                          end
                        </pre>
                      </td>
                    </tr>
                    </tbody>
                  </table>
                <h2>Inheritance</h2>
                <p>
                  Inheritance is a kind of downward chaining relationship between two classes (the super- class and the subclass), whereby one class “inherits” from another and the instances of the subclass acquire the behaviors—the methods—defined in the superclass.
                </p>
                <p>
                  In this example, Magazine inherits from Publication. Note the syntax in
                  Magazine’s class definition.
                </p><br />
                <pre>
                    <code data-language="ruby">
                  class Publication
                    attr_accessor :publisher
                  end
                  class Magazine &lt; Publication
                    attr_accessor :editor
                  end
                  mag = Magazine.new
                  mag.publisher = "David A. Black"
                  mag.editor = "Joe Smith"
                  puts "Mag is published by #{mag.publisher}, and edited by #{mag.editor}."
                  </code>
                </pre>
                <p>
                  The symbol &lt; designates Magazine as a subclass of Publication. Because every publi- cation object has publisher and publisher= methods (thanks to attr_accessor :publisher), every magazine object has those methods too. In addition, magazine objects have editor and editor= methods:
                </p>
                <h2>Single inheritance</h2>
                <p>
                  In some object-oriented languages, it’s possible for a given class to inherit from more than one class. You might, for example, have a Teacher class that inherits from a Person class and also inherits from an Employee class.Ruby doesn’t allow multiple inheritance; every Ruby class can have only one superclass, in keeping with the principle of single inheritance.
                  <br />
                  Despite what might be your first impression, Ruby’s single inheritance doesn’t restrict you: Ruby provides <i>modules</i>, which are bundles of programming functionality similar to classes (except that they don’t have instances), that you can easily graft onto your class’s family tree to provide as many methods for your objects as you need.(we will focus on modules later on)
                </p>
                <h2>Singleton methods</h2>
                <p>
                  Singleton methods, alao called as class methods serve a purpose, defining a method that we can invoke without creating new object of the class. Let's see following example:</p><br />
                  <pre>
                      <code data-language="ruby">
                    class Temperature
                      # note the method definition style
                      def Temperature.c2f(f)
                        f*9.0/5+32
                      end
                      def Temperature.f2c(c)
                        (c-32)*5/9.0
                      end
                    end
                    puts Temperature.c2f(100)
                    </code>
                  </pre>
                  <p>By defining Temperature.c2f, we’ve defined a method that we can access through the class object Temperature but not through its instances. One more singleton example.</p><br />
                  <pre>
                    <code data-language="ruby">
                    class Person
                      attr_accessor :name, :age
                      def initialize(name, age)
                        @name = name
                        @age = age
                      end
                      def Person.average_age(*persons)
                         total_age = 0
                         persons.each do |person|
                            total_age += person.age
                        end
                         puts "The average age of people are #{total_age/persons.size}"
                      end
                    end

                    p = Person.new('Mob', 23)
                    q = Person.new('Travis', 24)
                    r = Person.new('Lama', 21)
                    Person.average_age(p,q,r)
                    </code>
                  </pre>
                <h2>Re-Opening the Class</h2>
                <p> You can re-open any classes , redefine methods and add new methods.<br />Example:</p><br />
                <pre>
                    <code data-language="ruby">
                  str  = 'http://www.ruby-lang.org/en/'

                  # reopen string class and add method for checking if string is a link

                  class String
                    def is_link?
                     (/http|https/).match('http') ? true : false
                    end
                  end
                  puts str.is_link?
                  </code>
                </pre>
                <h2>Ruby self</h2>
                <p>
                  A Ruby class is an object of class Class. And all method calls in Ruby invoke with a receiver, which is the current object. We can refer to the current object by using keyword self, the same as this in Java in term of meaning but a slightly different usages.
                  <br />
                  Let's revist the class methods example:
                </p>
                <br />
                <pre>
                    <code data-language="ruby">
                    class Book
                      def self.title
                        true
                      end

                      def title
                        true
                      end
                    end
                    </code>
                  </pre>
                  <p>self refers to the object depends on its context. self.title in the above example will be invoked by the (current) object, Book. While title will be invoked by the object, Book.new. Therefore, to determine the value of self, you need to think around where the self resides.</p>
                  <h1>Modules</h1>
                  <p>Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.</p>
                  <ul>
                    <li>Modules provide a namespace and prevent name clashes.</li>
                    <li>Modules implement the mixin facility.</li>
                  </ul>
                  <p>Modules is actually very much like classes, in that it groups together some methods, constants, classes. One major difference is that they cannot be instantiated: you cannot call new on a module. They are also defined using the module keyword instead of using class:</p><br />
                  <pre>
                    <code data-language="ruby">
                      module DataVisualizer
                          class Grapher
                          end

                          class Plotter
                          end

                          def self.data_compatible?
                            puts "yes it works"
                          end
                      end
                      # can also be defined by this way
                      # module ClassMethods
                      #     def data_compatible?
                      #       puts "yes it works ok"
                      #     end
                      # end
                      #To access methods that modules
                      DataVisualizer.data_compatible?
                      #To access classes defined by modules
                      DataVisualizer::Grapher.new
                    </code>
                  </pre>
                  <p>When a class can inherit features from more than one parent class, the class is supposed to show multiple inheritance.

                  Ruby does not suppoprt mutiple inheritance directly but Ruby Modules have another, wonderful use. At a stroke, they pretty much eliminate the need for multiple inheritance, providing a facility called a mixin.

                  Mixins give you a wonderfully controlled way of adding functionality to classes. However, their true power comes out when the code in the mixin starts to interact with code in the class that uses it.</p><br />
                  <pre>
                    <code data-language="ruby">
                      module Greeting
                        # here below is the instance method
                        # and that can be accessed using object of class ONLY
                        def hi
                          puts 'Guest'
                        end
                      end
                      # Mixing class and module
                      class Person
                        include Greeting
                      end
                      person = Person.new
                      person.hi
                    </code>
                  </pre>
                  <h2>Include vs. Extend</h2>
                  <p>You can either use include or extend to mix in a module’s functionality into a class. The difference is this:
                    <ul>
                      <li>include makes the module’s methods available to the instance of a class, while</li>
                      <li>extend makes these methods available to the class itself.</li>
                    </ul>
                    Example:
                  </p> <br />
                  <pre>
                    <code data-language="ruby">
                      module Greetings
                        def say_hello
                          puts "Hello!"
                        end
                      end

                      class Human
                        include Greetings
                      end

                      Human.new.say_hello # => "Hello!"
                      #=> Human.say_hello     Gives NoMethodError

                      class Robot
                        extend Greetings
                      end

                      #=> Robot.new.say_hello Gives NoMethodError
                      Robot.say_hello     # => "Hello!"
                    </code>
                  </pre>
                  <h2>A Common Idiom</h2>
                  <p>Even though include is for adding instance methods, a common idiom you’ll see in Ruby is to use include to append both class and instance methods. The reason for this is that include has a self.included hook you can use to modify the class that is including a module and, to my knowledge, extend does not have a hook. It’s highly debatable, but often used so I figured I would mention it. Let’s look at an example.</p><br />
                  <pre>
                    <code data-language="ruby">
                      module Foo
                        def self.included(base)
                          base.extend(ClassMethods)
                        end

                        module ClassMethods
                          def bar
                            puts 'class method'
                          end
                        end

                        def foo
                          puts 'instance method'
                        end
                      end

                      class Baz
                        include Foo
                      end

                      Baz.bar # class method
                      Baz.new.foo # instance method
                    </code>
                  </pre>
                  <p>There are a ton of projects that use this idiom, including Rails, DataMapper, HTTParty, and HappyMapper.</p>
                  <h1>Blocks</h1>
                  <p>Ruby Code blocks (called closures in other languages) are definitely one of the coolest features of Ruby and are chunks of code between braces or between do- end that you can associate with method invocations, almost as if they were parameters. <br/>
                  The code in the block is not executed at the time it is encountered. Instead, Ruby remembers the context in which the block appears (the local variables, the current object, and so on) and then enters the method.</p>
                  <p><br />
                  <pre>
                    <code data-language="ruby">
                      arr = ['hen', 'goat', 'horse','cow']
                      # each with a block
                      arr.each{ |animal| puts animal }
                    </code>
                  </pre>
                  </p>
                  <p>
                    Let's see how it works.A method can then invoke an associated block one or more time using the Ruby yield statement. Thus any method that wants to take a block as a parameter can use the <b>yield</b> keyword to execute the block at any time.
                  </p><br />
                  <pre>
                    <code data-language="ruby">
                      def call_block
                        puts 'Start of method'
                        # you can call the block using the yield keyword
                        yield
                        yield
                        puts 'End of method'
                      end
                      # Code blocks may appear only in the source adjacent to a method call
                      call_block {puts 'In the block'}
                    </code>
                  </pre>
                  <p>
                    <b>Note</b> that the code in the block is not executed at the time it is encountered by the Ruby interpreter. Instead, Ruby remembers the context in which the block appears and then enters the method.
                    <br />
                    A code block's return value (like that of a method) is the value of the last expression evaluated in the code block. This return value is made available inside the method; it comes through as the return value of yield.

                    <i>block_given?</i> returns true if yield would execute a block in the current context. Refer to the following example:
                  </p><br/>
                  <pre><code data-language="ruby">
                    def try
                      if block_given?
                        yield
                      else
                        puts "no block"
                      end
                    end
                    try # => "no block"
                    try { puts "hello" } # => "hello"
                  </code></pre>
                  <p>You also can pass parameters with the yield statement. Here is an example:</p><br />
                  <pre>
                    <code data-language="ruby">
                      def test
                         yield 5
                         puts "You are in the method test"
                         yield 100
                      end
                      test {|i| puts "You are in the block #{i}"}
                    </code>
                  </pre>
                  <h2>Procs</h2>
                  <p>Proc(Procedure) objects are blocks of code that have been bound to a set of local variables. Once bound, the code may be called in different contexts and still access those variables.Like variables hold data, procs hold the code itself.Procs are first class objects of ruby with class Proc.</p><br />
                  <pre><code data-language="ruby">
                    # simple proc
                    a_proc = Proc.new{ puts 'I am in a proc.'}
                    a_proc.call

                    # a little advance
                    putser = Proc.new {|x| puts "x is #{x}" }
                    def foo(a,b)
                        a.call(b)
                    end
                    foo(putser, 34)
                    foo(putser, 22)
                  </code></pre>
                  <p>Difference between blocks and procs is blocks like procs are used to pass code to methods, but they are like undefined procs. ie they are not assigned to any variable, they are just passed to the methods. </p>
                  <h2>The ampersand (&amp;)</h2>
                  <p>The ampersand operator can be used to explicitly convert between blocks and Procs in a couple of esoteric cases. It is worthy to understand how these work.If a method want to accept a block but wants to use it as a proc, then add an &amp; in front of the last parameter(the parameter which will receive the block.</p><br />
                  <pre><code data-language="ruby">
                    def run_my_code(&amp;my_code)
                     my_code.call
                    end
                    run_my_code { puts "passing a block, accepting a proc"}
                  </code></pre>
                  <p>If you have a proc and you want to pass it to a method which accepts block, then when passing use a ampersand before the proc parameter.</p><br />
                  <pre><code data-language="ruby">
                     def run_my_code
                     yield
                    end
                    my_proc = Proc.new  { puts "passing a proc instead of block"}
                    #=> run_my_code(my_proc) #error, wrong number of arguments
                    run_my_code(&amp;my_proc) # passing a proc instead of block
                  </code></pre>
                  <p>
                    <strong>Important points</strong>
                    <ul>
                      <li>Only one block can be accepted by a method.</li>
                      <li>A block can be passed to any method, no need to define it.</li>
                      <li>To pass a proc instead of a block append an “&amp;” in front of the Proc.</li>
                    </ul>
                  </p>
                  <h2>Lambdas</h2>
                  <p>Lambda function are almost identical to Procs but with two key differences. First, a lambda checks the the number of arguments it receives and returns an ArgumentError if they do not match. For example:</p><br />
                  <pre><code data-language="ruby">
                    # simple lambda
                    l = lambda { puts "I'm a lambda" }
                    l.call

                    # lambda with params
                    l = lambda { |first,last| puts "Fullname: #{first} #{last}"}
                    l.call('Rohit', 'Rox')

                    # procs and lambda
                    l = lambda { |first,last| puts "Fullname: #{first} #{last}"}
                    #=> l.call('Rohit') will give error
                    p = Proc.new { |first,last| puts "Fullname: #{first} #{last}"}
                    p.call('Rohit')
                  </code></pre>
                  <p>Second, lambdas provide diminutive returns – meaning that when a Proc encounters a return statement in it’s execution, it halts the method and returns the provided value. Lambdas on the other hand, return their value to the method, allowing it to continue:</p><br />
                  <pre><code data-language="ruby">
                    def proc_math
                      Proc.new { return 1 + 1 }.call
                      return 2 + 2
                    end
                     
                    def lambda_math
                      lambda { return 1 + 1 }.call
                      return 2 + 2
                    end
                     
                    puts proc_math # => 2  
                    puts lambda_math # => 4  
                  </code></pre>
                <h2>More Comming Soon ..</h2>
              </div>
            </div>
          </div>
        </div>
        <!-- End content Div -->


      </div>
    </div>

    <script type="text/javascript" src="js/lib/jquery.js"></script>
    <script type="text/javascript" src="js/lib/sidetap.js"></script>
    <script type="text/javascript" src="js/lib/opal.js"></script>
    <script type="text/javascript" src="js/lib/opal_parser.js"></script>
    <script type="text/javascript" src="js/lib/opal_jquery.js"></script>
    <script type="text/javascript" src="js/lib/rainbow.js"></script>
    <script type="text/javascript" src="js/lib/rainbow.ruby.js"></script>
    <script>
      var st = sidetap();

      var about = $('#about');
      var home = $('#home');
      var ruby_home = $('#ruby_home');
      var history = $('#history');
      var fav = $('#fav')

      $(".header-button.menu").on("click",st.toggle_nav);
      $('#action_about, #link_to_about').click(function() {
        return st.show_section(about, {
          animation: 'upfrombottom'
        });
      });

      $('a.cancel').click(function() {
        return st.show_section(home, {
          animation: 'downfromtop'
        });
      });

      $('#link_to_ruby_home').click(function(){
        return st.show_section(ruby_home, {
          animation: 'rightfromleft'
        });
      });

      $('#link_to_history').click(function(){
        return st.show_section(history, {
          animation: 'rightfromleft'
        });
      });

      $('#link_to_fav').click(function(){
        return st.show_section(fav, {
          animation: 'rightfromleft'
        });
      });

      var RIT = {
        compile: function(code){
          var old_puts = Opal.puts,
          flush = [];
          Opal.puts = function (e) {
                flush.push(e), $('#output').html(flush.join("\n"));
            }
          $('#output').html('');
          try{
            var code=Opal.Opal.Parser.$new().$parse(code);
            eval(code);
            window.scrollTo("60%")
          }
          catch(err)
          {
            Opal.puts(""+err+"\n"+err.stack)
          }
        }
      }

      $('.run_me').click(function(){
        var code = $('#editor').val();
        if (code === ""){
          alert('Blank code.');
          return;
        }
        else
        {
          RIT.compile(code);
        }
      });
      $('#action_clear').click(function(){
        $('#editor').val('');
      });
      $(function(){
        var height = $(window).height();
        $('#editor').css('height',(70*height)/100);

        $('pre code').after('<div class="code_run_block"><a href="#" class="fav_this">Fav this</a><a href="#" class="run_or_edit_this">Edit or Run</a></div>');
        $('.run_or_edit_this').live('click', function(){
          var code = $(this).parent('div').siblings('code').text();
          st.show_section(home, {
            animation: 'downfromtop'
          });
          $('#editor').val(code);
        });
      });
    </script>
  </body>
</html>
